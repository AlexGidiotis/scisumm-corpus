Citance Number: 1 | Reference Article:  J87-1004.txt | Citing Article:  P90-1035.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset:  NA | Citation Text:  <S sid = NA ssid = NA></S> | Reference Offset:  NA | Reference Text:  <S sid = NA ssid = NA>Ron Kaplan, Martin Kay, Lauri Karttunen, and Stuart Shieber provided useful comments on the implementation of LFG and dag structure sharing.</S><S sid = NA ssid = NA>This can be avoided by using a tree-structured stack, which is described in the following subsection.</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 2 | Reference Article:  J87-1004.txt | Citing Article:  P90-1035.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset:  NA | Citation Text:  <S sid = NA ssid = NA>Similar to the work of Lang (1974) and Tomita (1987) extending LR parsers for arbitrary CFGs, the LR parsers for TAGs can be extended to solve by pseudo-parallelism the conflicts of moves.</S> | Reference Offset:  NA | Reference Text:  <S sid = NA ssid = NA>The pseudo-parallelism works as follows.</S><S sid = NA ssid = NA>Despite the availability of left-to-right algorithms, surprisingly few on-line parsers exist.</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 3 | Reference Article:  J87-1004.txt | Citing Article:  C94-1020.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset:  NA | Citation Text:  <S sid = NA ssid = NA>We developed a set of augmented context free grammar rules for general English syntactic analysis and the analyzer is implemented using Tomita LR parsing algorithm (Tomita, 1987).</S> | Reference Offset:  NA | Reference Text:  <S sid = NA ssid = NA>Thus, morphological rules, as well as syntactic rules, are written in the augmented context-free grammar.</S><S sid = NA ssid = NA>An Efficient Augmented-Context-Free Parsing Algorithm</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 4 | Reference Article:  J87-1004.txt | Citing Article:  D07-1130.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset:  NA | Citation Text:  <S sid = NA ssid = NA>The RASP parser is a generalized LR parser which builds a non-deterministic generalized LALR parse table from the grammar (Tomita, 1987).</S> | Reference Offset:  NA | Reference Text:  <S sid = NA ssid = NA>In this paper, however, we describe the algorithm as a generalized LR parsing algorithm only.</S><S sid = NA ssid = NA>Figures 2.1 and 2.2 show an example of a non-LR grammar and its parsing table.</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 5 | Reference Article:  J87-1004.txt | Citing Article:  P03-2003.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset:  NA | Citation Text:  <S sid = NA ssid = NA>a graph-structured stack (Tomita, 1987) was used to efficiently represent ambiguous index operations in a GIG stack.</S> | Reference Offset:  NA | Reference Text:  <S sid = NA ssid = NA>However, we do not necessarily have to copy the whole stack: even after different parallel operations on the tree-structured stack, the bottom portion of the stack may remain the same.</S><S sid = NA ssid = NA>We call this a tree-structured stack.</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 6 | Reference Article:  J87-1004.txt | Citing Article:  W07-2203.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset:  NA | Citation Text:  <S sid = NA ssid = NA>A context-free backbone is automatically derived from the unification grammar1 and a generalized or non-deterministic LALR(1) table is constructed from this backbone (Tomita, 1987).</S> | Reference Offset:  NA | Reference Text:  <S sid = NA ssid = NA>The parsing table can be obtained automatically from a context-free phrase structure grammar, using an algorithm first developed by DeRemer (1969, 1971).</S><S sid = NA ssid = NA>The algorithm is a generalized LR parsing algorithm, which precomputes an LR shift-reduce parsing table (possibly with multiple entries) from a given augmented context-free grammar.</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 7 | Reference Article:  J87-1004.txt | Citing Article:  P94-1040.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset:  NA | Citation Text:  <S sid = NA ssid = NA>The parsers create parse forests (Tomita, 1987) that incorporate subtree sharing (in which identical sub-analyses are shared between differing superordinate analyses) and node packing (where sub analyses covering the same portion of input whose root categories are in a subsumption relationship are merged into a single node).</S> | Reference Offset:  NA | Reference Text:  <S sid = NA ssid = NA>Such a node is called a packed node, and nodes before packing are called subnodes of the packed node.</S><S sid = NA ssid = NA>This section describes two techniques for providing an efficient representation: subtree sharing and local ambiguity packing.</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 8 | Reference Article:  J87-1004.txt | Citing Article:  P94-1040.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset:  NA | Citation Text:  <S sid = NA ssid = NA>In this parser, the LALR (1) technique (Aho, Sethi Ullman, 1986) is used, in conjunction with a graph-structured stack (Tomita, 1987), adapting for unification-based parsing Kipps's (1989) Tomita-like recogniser that achieves polynomial complexity on input length through caching.</S> | Reference Offset:  NA | Reference Text:  <S sid = NA ssid = NA>The exact definition and operation of the LR parser can be found in Aho and Ullman (1977).</S><S sid = NA ssid = NA>It is easy to show that the algorithm with the graph-structured stack does not parse any part of an input sentence more than once in the same way.</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 9 | Reference Article:  J87-1004.txt | Citing Article:  P10-1090.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset:  NA | Citation Text:  <S sid = NA ssid = NA>A forest (Tomita, 1987) compactly encodes an exponential number of parse trees.</S> | Reference Offset:  NA | Reference Text:  <S sid = NA ssid = NA>Thus, one might notice that, even with an efficient parsing algorithm such as the one we described, the parser would take exponential time because exponential time would be required merely to print out all parse trees (parse forest).</S><S sid = NA ssid = NA>Section 3 describes how to represent parse trees efficiently, so that all possible parse trees (the parse forest) take at most polynomial space as the ambiguity of a sentence grows exponentially.</S> | Discourse Facet:  NA | Annotator: Automatic


